;
; File generated by cc65 v 2.19 - Git f8cdb2a
;
	.fopt		compiler,"cc65 v 2.19 - Git f8cdb2a"
	.setcpu		"6502"
	.smart		on
	.autoimport	on
	.case		on
	.debuginfo	off
	.importzp	sp, sreg, regsave, regbank
	.importzp	tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
	.macpack	longbranch
	.forceimport	__STARTUP__
	.import		_pal_bg
	.import		_pal_spr
	.import		_pal_clear
	.import		_ppu_wait_nmi
	.import		_ppu_off
	.import		_ppu_on_all
	.import		_oam_clear
	.import		_oam_spr
	.import		_pad_poll
	.import		_bank_spr
	.import		_bank_bg
	.import		_vram_adr
	.import		_vram_fill
	.import		_vram_write
	.import		_memcpy
	.import		_memfill
	.import		_set_vram_buffer
	.import		_multi_vram_buffer_horz
	.import		_multi_vram_buffer_vert
	.import		_get_pad_new
	.import		_flush_vram_update2
	.export		_bankLevel
	.export		_bankBuffer
	.export		_banked_call
	.export		_bank_push
	.export		_bank_pop
	.import		_set_prg_8000
	.import		_set_chr_mode_2
	.import		_set_chr_mode_3
	.import		_set_chr_mode_4
	.import		_set_chr_mode_5
	.import		_set_mirroring
	.import		_set_extended_gfx
	.import		_disable_irq
	.export		_NUM_0
	.export		_NUM_1
	.export		_NUM_2
	.export		_NUM_3
	.export		_NUM_4
	.export		_NUM_5
	.export		_NUM_6
	.export		_NUM_7
	.export		_NUM_8
	.export		_NUM_9
	.export		_NUM_IN
	.export		_NUM_UNKNOWN
	.export		_Numbers
	.export		_Numbers_Length
	.export		_CAT_1_GAMES_TEXT
	.export		_CAT_NO
	.export		_CAT_SHF
	.export		_CAT_TXT
	.export		_pad1
	.export		_pad1_new
	.export		_text_offs
	.export		_dig_offset
	.export		_cart_inserted
	.export		_game_offset
	.export		_irq_array
	.export		_counter
	.export		_line
	.export		_delay_s
	.export		_tmp_digit
	.export		_digits
	.export		_menu_offset
	.export		_menu_hold_delay
	.export		_page
	.export		_m_d
	.export		_ar_pos
	.export		_ar_del
	.export		_text_tmp
	.export		_text_tmp_i
	.export		_x_pos_t
	.export		_x_pos_tl
	.export		_x_pos_ch
	.export		_MAXGAME
	.export		_rom_shift
	.export		_rom_name_offset
	.export		_bank_temp_8000
	.export		_d_cat
	.export		_s_delay
	.export		_wram_array
	.export		_MenuPal
	.export		_MenuPal_S
	.export		_IDENT
	.export		_COMPILE_DATE
	.export		_COMPILE_TIME
	.export		_blank
	.export		_DrawPage
	.export		_DrawText
	.import		_StartGame
	.export		_TestMode
	.import		_MultiMusic_Play
	.import		_PlaySnd
	.export		_IsCartridgeInserted
	.export		_RunGame
	.export		_draw_title
	.export		_main

.segment	"DATA"

_digits:
	.byte	$30
	.byte	$30
	.byte	$30
	.byte	$2E
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
_MAXGAME:
	.word	$00C8
_rom_shift:
	.word	$0000
_s_delay:
	.byte	$08

.segment	"RODATA"

.segment	"STARTUP"
_NUM_0:
	.byte	$20
	.byte	$21
	.byte	$22
	.byte	$24
	.byte	$25
	.byte	$26
	.byte	$28
	.byte	$29
	.byte	$2A
_NUM_1:
	.byte	$18
	.byte	$19
	.byte	$1A
	.byte	$1C
	.byte	$1D
	.byte	$1E
_NUM_2:
	.byte	$0F
	.byte	$4C
	.byte	$4D
	.byte	$13
	.byte	$50
	.byte	$51
	.byte	$17
	.byte	$54
	.byte	$55
_NUM_3:
	.byte	$1B
	.byte	$58
	.byte	$59
	.byte	$1F
	.byte	$5C
	.byte	$5D
	.byte	$23
	.byte	$60
	.byte	$61
_NUM_4:
	.byte	$00
	.byte	$01
	.byte	$02
	.byte	$04
	.byte	$05
	.byte	$06
	.byte	$08
	.byte	$09
	.byte	$0A
_NUM_5:
	.byte	$0C
	.byte	$0D
	.byte	$0E
	.byte	$10
	.byte	$11
	.byte	$12
	.byte	$14
	.byte	$15
	.byte	$16
_NUM_6:
	.byte	$03
	.byte	$40
	.byte	$41
	.byte	$07
	.byte	$44
	.byte	$45
	.byte	$0B
	.byte	$48
	.byte	$49
_NUM_7:
	.byte	$27
	.byte	$64
	.byte	$65
	.byte	$2B
	.byte	$68
	.byte	$69
	.byte	$2F
	.byte	$6C
	.byte	$6D
_NUM_8:
	.byte	$33
	.byte	$70
	.byte	$71
	.byte	$37
	.byte	$74
	.byte	$75
	.byte	$3B
	.byte	$78
	.byte	$79
_NUM_9:
	.byte	$42
	.byte	$43
	.byte	$46
	.byte	$47
	.byte	$4A
	.byte	$4B
	.byte	$4E
	.byte	$4F
	.byte	$52
_NUM_IN:
	.byte	$2C
	.byte	$2D
	.byte	$2E
	.byte	$30
	.byte	$31
	.byte	$32
	.byte	$34
	.byte	$35
	.byte	$36
	.byte	$38
	.byte	$39
	.byte	$3A
_NUM_UNKNOWN:
	.byte	$6A
	.byte	$6A
	.byte	$6A
	.res	3,$00
_Numbers:
	.addr	_NUM_0
	.addr	_NUM_1
	.addr	_NUM_2
	.addr	_NUM_3
	.addr	_NUM_4
	.addr	_NUM_5
	.addr	_NUM_6
	.addr	_NUM_7
	.addr	_NUM_8
	.addr	_NUM_9
	.addr	_NUM_UNKNOWN
_Numbers_Length:
	.byte	$03
	.byte	$02
	.byte	$03
	.byte	$03
	.byte	$03
	.byte	$03
	.byte	$03
	.byte	$03
	.byte	$03
	.byte	$03
	.byte	$01
_CAT_1_GAMES_TEXT:
	.byte	$32,$32,$32,$2D,$31
_CAT_NO:
	.word	$00DE
_CAT_SHF:
	.word	$0001
_CAT_TXT:
	.addr	_CAT_1_GAMES_TEXT
_MenuPal:
	.byte	$01
	.byte	$30
	.byte	$0F
	.byte	$0F
	.byte	$0F
	.byte	$0F
	.byte	$0F
	.byte	$0F
	.byte	$0F
	.byte	$0F
	.byte	$0F
	.byte	$0F
	.byte	$0F
	.byte	$0F
	.byte	$0F
	.byte	$0F
_MenuPal_S:
	.byte	$01
	.byte	$15
	.byte	$0F
	.byte	$0F
	.byte	$0F
	.byte	$0F
	.byte	$0F
	.byte	$0F
	.byte	$0F
	.byte	$0F
	.byte	$0F
	.byte	$0F
	.byte	$0F
	.byte	$0F
	.byte	$0F
	.byte	$0F
_IDENT:
	.byte	$44,$65,$76,$65,$6C,$6F,$70,$65,$64,$20,$75,$73,$69,$6E,$67,$20
	.byte	$4F,$70,$65,$6E,$4D,$75,$6C,$74,$69,$4C,$6F,$61,$64,$65,$72,$2C
	.byte	$20,$56,$65,$72,$73,$69,$6F,$6E,$20,$30,$2E,$31,$00
_COMPILE_DATE:
	.byte	$41,$70,$72,$20,$31,$36,$20,$32,$30,$32,$32,$00
_COMPILE_TIME:
	.byte	$32,$30,$3A,$35,$32,$3A,$31,$38,$00
.segment	"CODE"
_blank:
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00
	.byte	$00

.segment	"BSS"

_bankLevel:
	.res	1,$00
_bankBuffer:
	.res	10,$00
.segment	"ZEROPAGE"
_pad1:
	.res	1,$00
_pad1_new:
	.res	1,$00
_text_offs:
	.res	1,$00
_dig_offset:
	.res	1,$00
_cart_inserted:
	.res	1,$00
_game_offset:
	.res	2,$00
.segment	"BSS"
_irq_array:
	.res	64,$00
_counter:
	.res	1,$00
_line:
	.res	1,$00
_delay_s:
	.res	1,$00
_tmp_digit:
	.res	2,$00
_menu_offset:
	.res	2,$00
_menu_hold_delay:
	.res	1,$00
_page:
	.res	1,$00
_m_d:
	.res	1,$00
_ar_pos:
	.res	1,$00
_ar_del:
	.res	1,$00
_text_tmp:
	.res	32,$00
_text_tmp_i:
	.res	32,$00
_x_pos_t:
	.res	1,$00
_x_pos_tl:
	.res	1,$00
_x_pos_ch:
	.res	1,$00
_rom_name_offset:
	.res	2,$00
_bank_temp_8000:
	.res	1,$00
_d_cat:
	.res	1,$00
.segment	"XRAM"
_wram_array:
	.res	8192,$00

; ---------------------------------------------------------------
; void __near__ banked_call (unsigned char bankId, void (*method)(void))
; ---------------------------------------------------------------

.segment	"STARTUP"

.proc	_banked_call: near

.segment	"STARTUP"

;
; void banked_call(unsigned char bankId, void (*method)(void)) {
;
	jsr     pushax
;
; bank_push(bankId);
;
	ldy     #$02
	lda     (sp),y
	jsr     _bank_push
;
; (*method)();
;
	ldy     #$01
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	jsr     callax
;
; bank_pop();
;
	jsr     _bank_pop
;
; }
;
	jmp     incsp3

.endproc

; ---------------------------------------------------------------
; void __near__ bank_push (unsigned char bankId)
; ---------------------------------------------------------------

.segment	"STARTUP"

.proc	_bank_push: near

.segment	"STARTUP"

;
; void bank_push(unsigned char bankId) {
;
	jsr     pusha
;
; bankBuffer[bankLevel] = bankId;
;
	ldy     #$00
	lda     (sp),y
	ldy     _bankLevel
	sta     _bankBuffer,y
;
; ++bankLevel;
;
	inc     _bankLevel
;
; set_prg_8000(bankId);
;
	ldy     #$00
	lda     (sp),y
	jsr     _set_prg_8000
;
; }
;
	jmp     incsp1

.endproc

; ---------------------------------------------------------------
; void __near__ bank_pop (void)
; ---------------------------------------------------------------

.segment	"STARTUP"

.proc	_bank_pop: near

.segment	"STARTUP"

;
; --bankLevel;
;
	dec     _bankLevel
;
; if (bankLevel > 0) {
;
	beq     L0002
;
; set_prg_8000(bankBuffer[bankLevel-1]);
;
	ldx     #$00
	lda     _bankLevel
	sec
	sbc     #$01
	bcs     L0003
	dex
L0003:	sta     ptr1
	txa
	clc
	adc     #>(_bankBuffer)
	sta     ptr1+1
	ldy     #<(_bankBuffer)
	lda     (ptr1),y
	jmp     _set_prg_8000
;
; }
;
L0002:	rts

.endproc

; ---------------------------------------------------------------
; void __near__ DrawPage (unsigned char page, unsigned char fast)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_DrawPage: near

.segment	"CODE"

;
; void DrawPage(unsigned char page, unsigned char fast) {  
;
	jsr     pusha
;
; if (!fast) {
;
	ldy     #$00
	lda     (sp),y
	bne     L0002
;
; set_vram_buffer();    
;
	jsr     _set_vram_buffer
;
; oam_clear();
;
	jsr     _oam_clear
;
; oam_spr(M_X, M_Y+(16*(menu_offset%MAXLINES)), ARR_OFFSET, 0x0);
;
	jsr     decsp3
	lda     #$30
	ldy     #$02
	sta     (sp),y
	lda     _menu_offset
	ldx     _menu_offset+1
	jsr     pushax
	ldx     #$00
	lda     #$08
	jsr     tosmoda0
	asl     a
	asl     a
	asl     a
	asl     a
	clc
	adc     #$42
	ldy     #$01
	sta     (sp),y
	lda     #$B6
	dey
	sta     (sp),y
	tya
	jsr     _oam_spr
;
; oam_spr(M_X+8, M_Y+(16*(menu_offset%MAXLINES)), ARR_OFFSET+1, 0x0);
;
	jsr     decsp3
	lda     #$38
	ldy     #$02
	sta     (sp),y
	lda     _menu_offset
	ldx     _menu_offset+1
	jsr     pushax
	ldx     #$00
	lda     #$08
	jsr     tosmoda0
	asl     a
	asl     a
	asl     a
	asl     a
	clc
	adc     #$42
	ldy     #$01
	sta     (sp),y
	lda     #$B7
	dey
	sta     (sp),y
	tya
	jsr     _oam_spr
;
; for (line = 0; line<MAXLINES; line++) {
;
L0002:	lda     #$00
	sta     _line
L002C:	lda     _line
	cmp     #$08
	jcs     L0006
;
; memfill(text_tmp_i, 0x0, sizeof(text_tmp_i));
;
	jsr     decsp3
	lda     #<(_text_tmp_i)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(_text_tmp_i)
	sta     (sp),y
	lda     #$00
	tay
	sta     (sp),y
	tax
	lda     #$20
	jsr     _memfill
;
; tmp_digit = (MAXLINES*page)+line+1;  
;
	ldy     #$01
	ldx     #$00
	lda     (sp),y
	jsr     shlax3
	clc
	adc     _line
	bcc     L0027
	inx
	clc
L0027:	adc     #$01
	bcc     L0009
	inx
L0009:	sta     _tmp_digit
	stx     _tmp_digit+1
;
; dig_offset = 2;
;
	lda     #$02
	sta     _dig_offset
;
; if (tmp_digit > MAXGAME) {
;
	lda     _tmp_digit
	sec
	sbc     _MAXGAME
	sta     tmp1
	lda     _tmp_digit+1
	sbc     _MAXGAME+1
	ora     tmp1
	bcc     L000A
	beq     L000A
;
; text_tmp_i[0] = 0x00;
;
	lda     #$00
	sta     _text_tmp_i
;
; text_tmp_i[1] = 0x00;
;
	sta     _text_tmp_i+1
;
; text_tmp_i[2] = 0x00;
;
	sta     _text_tmp_i+2
;
; text_tmp_i[3] = 0x00;
;
	sta     _text_tmp_i+3
;
; } else {   
;
	jmp     L000B
;
; digits[3] = 0x2e;               
;
L000A:	lda     #$2E
	sta     _digits+3
;
; digits[2] = (tmp_digit % 10) + 0x30;
;
	lda     _tmp_digit
	ldx     _tmp_digit+1
	jsr     pushax
	lda     #$0A
	jsr     tosumoda0
	clc
	adc     #$30
	sta     _digits+2
;
; tmp_digit /= 10;   
;
	lda     _tmp_digit
	ldx     _tmp_digit+1
	jsr     pushax
	lda     #$0A
	jsr     tosudiva0
	sta     _tmp_digit
	stx     _tmp_digit+1
;
; digits[1] = (tmp_digit % 10) + 0x30;  
;
	jsr     pushax
	lda     #$0A
	jsr     tosumoda0
	clc
	adc     #$30
	sta     _digits+1
;
; if (((MAXLINES*page)+line+1) >= 10) {
;
	ldy     #$01
	ldx     #$00
	lda     (sp),y
	jsr     shlax3
	clc
	adc     _line
	bcc     L0028
	inx
	clc
L0028:	adc     #$01
	bcc     L000F
	inx
L000F:	cmp     #$0A
	txa
	sbc     #$00
	bvs     L0010
	eor     #$80
L0010:	bpl     L002D
;
; digits[1] = (tmp_digit % 10) + 0x30;            
;
	lda     _tmp_digit
	ldx     _tmp_digit+1
	jsr     pushax
	lda     #$0A
	jsr     tosumoda0
	clc
	adc     #$30
;
; } else {
;
	jmp     L0025
;
; dig_offset--;
;
L002D:	dec     _dig_offset
;
; digits[1] = 0x00;
;
	lda     #$00
L0025:	sta     _digits+1
;
; tmp_digit /= 10;
;
	lda     _tmp_digit
	ldx     _tmp_digit+1
	jsr     pushax
	lda     #$0A
	jsr     tosudiva0
	sta     _tmp_digit
	stx     _tmp_digit+1
;
; digits[0] = (tmp_digit % 10) + 0x30;
;
	jsr     pushax
	lda     #$0A
	jsr     tosumoda0
	clc
	adc     #$30
	sta     _digits
;
; if (((MAXLINES*page)+line+1) >= 100) {
;
	ldy     #$01
	ldx     #$00
	lda     (sp),y
	jsr     shlax3
	clc
	adc     _line
	bcc     L0029
	inx
	clc
L0029:	adc     #$01
	bcc     L0015
	inx
L0015:	cmp     #$64
	txa
	sbc     #$00
	bvs     L0016
	eor     #$80
L0016:	bpl     L002E
;
; digits[0] = (tmp_digit % 10) + 0x30;
;
	lda     _tmp_digit
	ldx     _tmp_digit+1
	jsr     pushax
	lda     #$0A
	jsr     tosumoda0
	clc
	adc     #$30
;
; } else {
;
	jmp     L0026
;
; dig_offset--;
;
L002E:	dec     _dig_offset
;
; digits[0] = 0x00;
;
	lda     #$00
L0026:	sta     _digits
;
; memcpy(text_tmp_i+dig_offset, digits, 4);
;
L000B:	lda     #<(_text_tmp_i)
	ldx     #>(_text_tmp_i)
	clc
	adc     _dig_offset
	bcc     L0019
	inx
L0019:	jsr     pushax
	lda     #<(_digits)
	ldx     #>(_digits)
	jsr     pushax
	ldx     #$00
	lda     #$04
	jsr     _memcpy
;
; if (tmp_digit > MAXGAME) {
;
	lda     _tmp_digit
	sec
	sbc     _MAXGAME
	sta     tmp1
	lda     _tmp_digit+1
	sbc     _MAXGAME+1
	ora     tmp1
	bcc     L001A
	beq     L001A
;
; memfill(text_tmp_i, 0x00, sizeof(text_tmp_i));
;
	jsr     decsp3
	lda     #<(_text_tmp_i)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(_text_tmp_i)
	sta     (sp),y
	lda     #$00
	tay
	sta     (sp),y
	tax
	lda     #$20
	jsr     _memfill
;
; } else {
;
	jmp     L001B
;
; rom_name_offset = (16*(line+rom_shift)) + (16*MAXLINES)*page;
;
L001A:	lda     _line
	clc
	adc     _rom_shift
	pha
	lda     #$00
	adc     _rom_shift+1
	tax
	pla
	jsr     shlax4
	sta     ptr1
	stx     ptr1+1
	ldx     #$00
	ldy     #$01
	lda     (sp),y
	jsr     shlax4
	jsr     shlax3
	clc
	adc     ptr1
	pha
	txa
	adc     ptr1+1
	tax
	pla
	sta     _rom_name_offset
	stx     _rom_name_offset+1
;
; set_prg_8000(rom_name_offset >= 0x2000 ? ROM_NAMES+1 : ROM_NAMES);
;
	cmp     #$00
	txa
	sbc     #$20
	bcc     L002F
	lda     #$3C
	jmp     L0030
L002F:	lda     #$3B
L0030:	jsr     _set_prg_8000
;
; memcpy(text_tmp_i+(dig_offset+4), &PEEK(0x8000 + (rom_name_offset % 0x2000)), 16);
;
	ldx     #$00
	lda     _dig_offset
	clc
	adc     #$04
	bcc     L002A
	inx
	clc
L002A:	adc     #<(_text_tmp_i)
	tay
	txa
	adc     #>(_text_tmp_i)
	tax
	tya
	jsr     pushax
	lda     _rom_name_offset+1
	and     #$1F
	tax
	lda     _rom_name_offset
	pha
	txa
	clc
	adc     #$80
	tax
	pla
	jsr     pushax
	ldx     #$00
	lda     #$10
	jsr     _memcpy
;
; DrawText(text_tmp_i+2, 20, NTADR_A(8,TEXT_OFFSET+(2*line)), fast);
;
L001B:	jsr     decsp5
	lda     #<(_text_tmp_i+2)
	ldy     #$03
	sta     (sp),y
	iny
	lda     #>(_text_tmp_i+2)
	sta     (sp),y
	lda     #$14
	ldy     #$02
	sta     (sp),y
	ldx     #$00
	lda     _line
	asl     a
	bcc     L002B
	inx
	clc
L002B:	adc     #$08
	bcc     L001F
	inx
L001F:	jsr     aslax4
	stx     tmp1
	asl     a
	rol     tmp1
	ora     #$08
	pha
	lda     tmp1
	ora     #$20
	tax
	pla
	ldy     #$00
	sta     (sp),y
	iny
	txa
	sta     (sp),y
	ldy     #$05
	lda     (sp),y
	jsr     _DrawText
;
; if (!fast) ppu_wait_nmi();
;
	ldy     #$00
	lda     (sp),y
	bne     L0007
	jsr     _ppu_wait_nmi
;
; for (line = 0; line<MAXLINES; line++) {
;
L0007:	inc     _line
	jmp     L002C
;
; }
;
L0006:	jmp     incsp2

.endproc

; ---------------------------------------------------------------
; void __near__ DrawText (unsigned char *text, unsigned char length, int address, unsigned char fast)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_DrawText: near

.segment	"CODE"

;
; void DrawText(unsigned char *text, unsigned char length, int address, unsigned char fast) {
;
	jsr     pusha
;
; memfill(text_tmp, 0, sizeof(text_tmp));
;
	jsr     decsp3
	lda     #<(_text_tmp)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(_text_tmp)
	sta     (sp),y
	lda     #$00
	tay
	sta     (sp),y
	tax
	lda     #$20
	jsr     _memfill
;
; for (text_offs = 0; text_offs<length; text_offs++) {
;
	lda     #$00
	sta     _text_offs
L005E:	lda     _text_offs
	ldy     #$03
	cmp     (sp),y
	jcs     L0003
;
; if (text[text_offs] >= 0x30 && text[text_offs] <= 0x39) {
;
	ldy     #$05
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	ldy     _text_offs
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	cmp     #$30
	bcc     L0006
	ldy     #$05
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	ldy     _text_offs
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	cmp     #$3A
	bcs     L0006
;
; text_tmp[text_offs] = 2*(text[text_offs]-0x30)+0x20+CHARA_OFFSET;
;
	lda     #<(_text_tmp)
	ldx     #>(_text_tmp)
	clc
	adc     _text_offs
	bcc     L000A
	inx
L000A:	sta     sreg
	stx     sreg+1
	ldy     #$05
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	ldy     _text_offs
	sta     ptr1
	stx     ptr1+1
	ldx     #$00
	lda     (ptr1),y
	sec
	sbc     #$30
	bcs     L000B
	dex
L000B:	stx     tmp1
	asl     a
	rol     tmp1
	clc
	adc     #$20
;
; } else if (text[text_offs] >= 0x00 && text[text_offs] <= 0x1f) {
;
	jmp     L0074
L0006:	ldy     #$05
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	ldy     _text_offs
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	cmp     #$20
	bcs     L000F
;
; text_tmp[text_offs] = 0x00+CHARA_OFFSET;
;
	ldy     _text_offs
	lda     #$80
	sta     _text_tmp,y
;
; } else if (text[text_offs] >= 0x20 && text[text_offs] <= 0x2f) {
;
	jmp     L0066
L000F:	ldy     #$05
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	ldy     _text_offs
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	cmp     #$20
	bcc     L0014
	ldy     #$05
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	ldy     _text_offs
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	cmp     #$30
	bcs     L0014
;
; text_tmp[text_offs] = 2*(text[text_offs]-0x20)+CHARA_OFFSET;
;
	lda     #<(_text_tmp)
	ldx     #>(_text_tmp)
	clc
	adc     _text_offs
	bcc     L0018
	inx
L0018:	sta     sreg
	stx     sreg+1
	ldy     #$05
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	ldy     _text_offs
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	sec
	sbc     #$20
	asl     a
;
; } else {
;
	jmp     L0074
;
; text_tmp[text_offs] = 2*(text[text_offs]-0x40)+0x40+CHARA_OFFSET;
;
L0014:	lda     #<(_text_tmp)
	ldx     #>(_text_tmp)
	clc
	adc     _text_offs
	bcc     L001C
	inx
L001C:	sta     sreg
	stx     sreg+1
	ldy     #$05
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	ldy     _text_offs
	sta     ptr1
	stx     ptr1+1
	ldx     #$00
	lda     (ptr1),y
	sec
	sbc     #$40
	bcs     L001D
	dex
L001D:	stx     tmp1
	asl     a
	rol     tmp1
	clc
	adc     #$40
L0074:	clc
	adc     #$80
	ldy     #$00
	sta     (sreg),y
;
; for (text_offs = 0; text_offs<length; text_offs++) {
;
L0066:	inc     _text_offs
	jmp     L005E
;
; if (fast) {
;
L0003:	ldy     #$00
	lda     (sp),y
	beq     L0020
;
; vram_adr(address);
;
	ldy     #$02
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	jsr     _vram_adr
;
; vram_write(text_tmp, length);
;
	lda     #<(_text_tmp)
	ldx     #>(_text_tmp)
	jsr     pushax
	ldy     #$05
	ldx     #$00
	lda     (sp),y
	jsr     _vram_write
;
; } else {
;
	jmp     L0021
;
; set_vram_buffer();
;
L0020:	jsr     _set_vram_buffer
;
; multi_vram_buffer_horz(text_tmp, length, address);
;
	jsr     decsp3
	lda     #<(_text_tmp)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(_text_tmp)
	sta     (sp),y
	ldy     #$06
	lda     (sp),y
	ldy     #$00
	sta     (sp),y
	ldy     #$05
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	jsr     _multi_vram_buffer_horz
;
; if (!fast) ppu_wait_nmi();
;
L0021:	ldy     #$00
	lda     (sp),y
	bne     L0022
	jsr     _ppu_wait_nmi
;
; for (text_offs = 0; text_offs<length; text_offs++) {
;
L0022:	lda     #$00
	sta     _text_offs
L0067:	lda     _text_offs
	ldy     #$03
	cmp     (sp),y
	jcs     L0024
;
; if (text[text_offs] >= 0x30 && text[text_offs] <= 0x39) {
;
	ldy     #$05
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	ldy     _text_offs
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	cmp     #$30
	bcc     L0027
	ldy     #$05
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	ldy     _text_offs
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	cmp     #$3A
	bcs     L0027
;
; text_tmp[text_offs] = 2*(text[text_offs]-0x30)+0x20+1+CHARA_OFFSET;
;
	lda     #<(_text_tmp)
	ldx     #>(_text_tmp)
	clc
	adc     _text_offs
	bcc     L002B
	inx
L002B:	sta     sreg
	stx     sreg+1
	ldy     #$05
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	ldy     _text_offs
	sta     ptr1
	stx     ptr1+1
	ldx     #$00
	lda     (ptr1),y
	sec
	sbc     #$30
	bcs     L002C
	dex
L002C:	stx     tmp1
	asl     a
	rol     tmp1
	clc
	adc     #$20
;
; } else if (text[text_offs] >= 0x00 && text[text_offs] <= 0x1f) {
;
	jmp     L0077
L0027:	ldy     #$05
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	ldy     _text_offs
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	cmp     #$20
	bcs     L0031
;
; text_tmp[text_offs] = 0x00+CHARA_OFFSET;
;
	ldy     _text_offs
	lda     #$80
	sta     _text_tmp,y
;
; } else if (text[text_offs] >= 0x20 && text[text_offs] <= 0x2f) {
;
	jmp     L006F
L0031:	ldy     #$05
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	ldy     _text_offs
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	cmp     #$20
	bcc     L0036
	ldy     #$05
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	ldy     _text_offs
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	cmp     #$30
	bcs     L0036
;
; text_tmp[text_offs] = 2*(text[text_offs]-0x20)+1+CHARA_OFFSET;
;
	lda     #<(_text_tmp)
	ldx     #>(_text_tmp)
	clc
	adc     _text_offs
	bcc     L003A
	inx
L003A:	sta     sreg
	stx     sreg+1
	ldy     #$05
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	ldy     _text_offs
	sta     ptr1
	stx     ptr1+1
	ldx     #$00
	lda     (ptr1),y
	sec
	sbc     #$20
	bcs     L003B
	dex
L003B:	stx     tmp1
	asl     a
	rol     tmp1
;
; } else {
;
	jmp     L0076
;
; text_tmp[text_offs] = 2*(text[text_offs]-0x40)+0x40+1+CHARA_OFFSET;
;
L0036:	lda     #<(_text_tmp)
	ldx     #>(_text_tmp)
	clc
	adc     _text_offs
	bcc     L003F
	inx
L003F:	sta     sreg
	stx     sreg+1
	ldy     #$05
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	ldy     _text_offs
	sta     ptr1
	stx     ptr1+1
	ldx     #$00
	lda     (ptr1),y
	sec
	sbc     #$40
	bcs     L0040
	dex
L0040:	stx     tmp1
	asl     a
	rol     tmp1
	clc
	adc     #$40
L0077:	bcc     L005D
L0076:	clc
L005D:	adc     #$01
	clc
	adc     #$80
	ldy     #$00
	sta     (sreg),y
;
; for (text_offs = 0; text_offs<length; text_offs++) {
;
L006F:	inc     _text_offs
	jmp     L0067
;
; if (fast) {
;
L0024:	ldy     #$00
	lda     (sp),y
	beq     L0044
;
; vram_adr(address+0x20);
;
	ldy     #$02
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	clc
	adc     #$20
	bcc     L0045
	inx
L0045:	jsr     _vram_adr
;
; vram_write(text_tmp, length);
;
	lda     #<(_text_tmp)
	ldx     #>(_text_tmp)
	jsr     pushax
	ldy     #$05
	ldx     #$00
	lda     (sp),y
	jsr     _vram_write
;
; } else {
;
	jmp     L0046
;
; set_vram_buffer();
;
L0044:	jsr     _set_vram_buffer
;
; multi_vram_buffer_horz(text_tmp, length, address+0x20);
;
	jsr     decsp3
	lda     #<(_text_tmp)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(_text_tmp)
	sta     (sp),y
	ldy     #$06
	lda     (sp),y
	ldy     #$00
	sta     (sp),y
	ldy     #$05
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	clc
	adc     #$20
	bcc     L0047
	inx
L0047:	jsr     _multi_vram_buffer_horz
;
; }
;
L0046:	jmp     incsp6

.endproc

; ---------------------------------------------------------------
; void __near__ TestMode (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_TestMode: near

.segment	"CODE"

;
; RunGame(TESTROM);
;
	ldx     #$00
	txa
	jmp     _RunGame

.endproc

; ---------------------------------------------------------------
; unsigned char __near__ IsCartridgeInserted (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_IsCartridgeInserted: near

.segment	"CODE"

;
; return !(PEEK(0x412d) & 0x1);
;
	lda     $412D
	and     #$01
	jsr     bnega
	ldx     #$00
;
; };
;
	rts

.endproc

; ---------------------------------------------------------------
; void __near__ RunGame (unsigned int game)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_RunGame: near

.segment	"CODE"

;
; void RunGame(unsigned int game) { 
;
	jsr     pushax
;
; game += rom_shift;
;
	lda     _rom_shift
	ldx     _rom_shift+1
	jsr     addeq0sp
;
; set_prg_8000(ROM_OFFSETS);
;
	lda     #$38
	jsr     _set_prg_8000
;
; game_offset = (PEEK( 0x8001+(2*game) ) << 8) | PEEK( 0x8000+(2*game));
;
	ldy     #$01
	lda     (sp),y
	sta     tmp1
	dey
	lda     (sp),y
	asl     a
	rol     tmp1
	clc
	adc     #$01
	sta     ptr1
	lda     tmp1
	adc     #$80
	sta     ptr1+1
	lda     (ptr1),y
	sta     sreg+1
	iny
	lda     (sp),y
	sta     tmp1
	dey
	lda     (sp),y
	asl     a
	rol     tmp1
	sta     ptr1
	lda     tmp1
	clc
	adc     #$80
	sta     ptr1+1
	lda     (ptr1),y
	sta     _game_offset
	lda     sreg+1
	sta     _game_offset+1
;
; set_extended_gfx(0);
;
	tya
	jsr     _set_extended_gfx
;
; pal_clear();
;
	jsr     _pal_clear
;
; oam_clear();
;
	jsr     _oam_clear
;
; ppu_wait_nmi();
;
	jsr     _ppu_wait_nmi
;
; ppu_off();
;
	jsr     _ppu_off
;
; disable_irq();   
;
	jsr     _disable_irq
;
; vram_adr(NTADR_A(0,0));
;
	ldx     #$20
	lda     #$00
	jsr     _vram_adr
;
; vram_fill(0x00, 0x1000);   
;
	lda     #$00
	jsr     pusha
	ldx     #$10
	jsr     _vram_fill
;
; memfill(wram_array,0,0x2000); 
;
	jsr     decsp3
	lda     #<(_wram_array)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(_wram_array)
	sta     (sp),y
	lda     #$00
	tay
	sta     (sp),y
	ldx     #$20
	jsr     _memfill
;
; set_prg_8000(game >= 744 ? ROM_BANK+1 : ROM_BANK);
;
	ldy     #$01
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	cmp     #$E8
	txa
	sbc     #$02
	bcc     L0004
	lda     #$3A
	jmp     L0005
L0004:	lda     #$39
L0005:	jsr     _set_prg_8000
;
; StartGame(game_offset);
;
	lda     _game_offset
	ldx     _game_offset+1
	jsr     _StartGame
;
; }
;
	jmp     incsp2

.endproc

; ---------------------------------------------------------------
; void __near__ draw_title (unsigned char *text, unsigned char textlen)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_draw_title: near

.segment	"CODE"

;
; void draw_title(unsigned char *text, unsigned char textlen) { 
;
	jsr     pusha
;
; x_pos_tl = 0;
;
	lda     #$00
	sta     _x_pos_tl
;
; for (x_pos_ch = 0; x_pos_ch<textlen; x_pos_ch++) {
;
	sta     _x_pos_ch
L002D:	lda     _x_pos_ch
	ldy     #$00
	cmp     (sp),y
	jcs     L0003
;
; if (text[x_pos_ch] == 0x2d) {
;
	ldy     #$02
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	ldy     _x_pos_ch
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	cmp     #$2D
	bne     L0006
;
; x_pos_tl += 1;
;
	inc     _x_pos_tl
;
; for (x_pos_t = 0; x_pos_t<4; x_pos_t++) {
;
	lda     #$00
	sta     _x_pos_t
L002E:	lda     _x_pos_t
	cmp     #$04
	bcs     L002F
;
; set_vram_buffer();
;
	jsr     _set_vram_buffer
;
; multi_vram_buffer_vert(NUM_IN+(3*x_pos_t), 3, NTADR_A(B_X_OFFS+x_pos_t+x_pos_tl, B_Y_OFFS));
;
	jsr     decsp3
	ldx     #$00
	lda     _x_pos_t
	jsr     mulax3
	clc
	adc     #<(_NUM_IN)
	tay
	txa
	adc     #>(_NUM_IN)
	tax
	tya
	ldy     #$01
	sta     (sp),y
	iny
	txa
	sta     (sp),y
	lda     #$03
	ldy     #$00
	sta     (sp),y
	ldx     #$00
	lda     _x_pos_t
	clc
	adc     #$07
	bcc     L002A
	inx
	clc
L002A:	adc     _x_pos_tl
	bcc     L0020
	inx
L0020:	ora     #$60
	pha
	txa
	ora     #$20
	tax
	pla
	jsr     _multi_vram_buffer_vert
;
; flush_vram_update2();
;
	jsr     _flush_vram_update2
;
; for (x_pos_t = 0; x_pos_t<4; x_pos_t++) {
;
	inc     _x_pos_t
	jmp     L002E
;
; x_pos_tl += 5;
;
L002F:	lda     #$05
;
; } else if (text[x_pos_ch] >= 0x30 && text[x_pos_ch] <= 0x39) {
;
	jmp     L0038
L0006:	ldy     #$02
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	ldy     _x_pos_ch
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	cmp     #$30
	lda     #$00
	jcc     L0034
	ldy     #$02
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	ldy     _x_pos_ch
	sta     ptr1
	stx     ptr1+1
	lda     (ptr1),y
	cmp     #$3A
	bcc     L0032
	lda     #$00
	jmp     L0034
;
; for (x_pos_t = 0; x_pos_t<Numbers_Length[text[x_pos_ch]-0x30]; x_pos_t++) {
;
L0032:	lda     #$00
	sta     _x_pos_t
L0011:	ldy     #$02
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	ldy     _x_pos_ch
	sta     ptr1
	stx     ptr1+1
	ldx     #$00
	lda     (ptr1),y
	sec
	sbc     #$30
	bcs     L0015
	dex
L0015:	sta     ptr1
	txa
	clc
	adc     #>(_Numbers_Length)
	sta     ptr1+1
	ldy     #<(_Numbers_Length)
	lda     (ptr1),y
	cmp     _x_pos_t
	jeq     L0012
	jcc     L0012
;
; set_vram_buffer();
;
	jsr     _set_vram_buffer
;
; multi_vram_buffer_vert(Numbers[text[x_pos_ch]-0x30]+(3*x_pos_t), 3, NTADR_A(B_X_OFFS+x_pos_t+x_pos_tl, B_Y_OFFS));    
;
	jsr     decsp3
	ldy     #$05
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	ldy     _x_pos_ch
	sta     ptr1
	stx     ptr1+1
	ldx     #$00
	lda     (ptr1),y
	sec
	sbc     #$30
	bcs     L0016
	dex
L0016:	stx     tmp1
	asl     a
	rol     tmp1
	clc
	adc     #<(_Numbers)
	sta     ptr1
	lda     tmp1
	adc     #>(_Numbers)
	sta     ptr1+1
	ldy     #$01
	lda     (ptr1),y
	tax
	dey
	lda     (ptr1),y
	sta     sreg
	stx     sreg+1
	ldx     #$00
	lda     _x_pos_t
	jsr     mulax3
	clc
	adc     sreg
	pha
	txa
	adc     sreg+1
	tax
	pla
	iny
	sta     (sp),y
	iny
	txa
	sta     (sp),y
	lda     #$03
	ldy     #$00
	sta     (sp),y
	ldx     #$00
	lda     _x_pos_t
	clc
	adc     #$07
	bcc     L002B
	inx
	clc
L002B:	adc     _x_pos_tl
	bcc     L0025
	inx
L0025:	ora     #$60
	pha
	txa
	ora     #$20
	tax
	pla
	jsr     _multi_vram_buffer_vert
;
; flush_vram_update2();
;
	jsr     _flush_vram_update2
;
; for (x_pos_t = 0; x_pos_t<Numbers_Length[text[x_pos_ch]-0x30]; x_pos_t++) {
;
	inc     _x_pos_t
	jmp     L0011
;
; x_pos_tl += Numbers_Length[text[x_pos_ch]-0x30];
;
L0012:	ldy     #$02
	lda     (sp),y
	tax
	dey
	lda     (sp),y
	ldy     _x_pos_ch
	sta     ptr1
	stx     ptr1+1
	ldx     #$00
	lda     (ptr1),y
	sec
	sbc     #$30
	bcs     L0018
	dex
L0018:	sta     ptr1
	txa
	clc
	adc     #>(_Numbers_Length)
	sta     ptr1+1
	ldy     #<(_Numbers_Length)
	lda     (ptr1),y
;
; } else {
;
	jmp     L0038
;
; for (x_pos_t = 0; x_pos_t<Numbers_Length[10]; x_pos_t++) {
;
L0034:	sta     _x_pos_t
L0035:	lda     _x_pos_t
	cmp     _Numbers_Length+10
	bcs     L0036
;
; set_vram_buffer();
;
	jsr     _set_vram_buffer
;
; multi_vram_buffer_vert(Numbers[10]+(3*x_pos_t), 3, NTADR_A(B_X_OFFS+x_pos_t+x_pos_tl, B_Y_OFFS));    
;
	jsr     decsp3
	ldx     #$00
	lda     _x_pos_t
	jsr     mulax3
	clc
	adc     _Numbers+20
	pha
	txa
	adc     _Numbers+20+1
	tax
	pla
	ldy     #$01
	sta     (sp),y
	iny
	txa
	sta     (sp),y
	lda     #$03
	ldy     #$00
	sta     (sp),y
	ldx     #$00
	lda     _x_pos_t
	clc
	adc     #$07
	bcc     L002C
	inx
	clc
L002C:	adc     _x_pos_tl
	bcc     L0027
	inx
L0027:	ora     #$60
	pha
	txa
	ora     #$20
	tax
	pla
	jsr     _multi_vram_buffer_vert
;
; flush_vram_update2();
;
	jsr     _flush_vram_update2
;
; for (x_pos_t = 0; x_pos_t<Numbers_Length[10]; x_pos_t++) {
;
	inc     _x_pos_t
	jmp     L0035
;
; x_pos_tl += Numbers_Length[10];
;
L0036:	lda     _Numbers_Length+10
L0038:	clc
	adc     _x_pos_tl
	sta     _x_pos_tl
;
; for (x_pos_ch = 0; x_pos_ch<textlen; x_pos_ch++) {
;
	inc     _x_pos_ch
	jmp     L002D
;
; }
;
L0003:	jmp     incsp3

.endproc

; ---------------------------------------------------------------
; void __near__ main (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_main: near

.segment	"CODE"

;
; set_mirroring(MIRROR_VERTICAL);            
;
	lda     #$00
	jsr     _set_mirroring
;
; set_prg_8000(ROM_NAMETABLE+1);
;
	lda     #$35
	jsr     _set_prg_8000
;
; bank_spr(0);
;
	lda     #$00
	jsr     _bank_spr
;
; bank_bg(0);
;
	lda     #$00
	jsr     _bank_bg
;
; POKE(0x410b, 0x80); // MMC3-like Scanlines
;
	lda     #$80
	sta     $410B
;
; set_chr_mode_2(ROM_CHR);
;
	jsr     _set_chr_mode_2
;
; set_chr_mode_3(ROM_CHR+1);
;
	lda     #$81
	jsr     _set_chr_mode_3
;
; set_chr_mode_4(ROM_CHR+2);
;
	lda     #$82
	jsr     _set_chr_mode_4
;
; set_chr_mode_5(ROM_CHR+3);
;
	lda     #$83
	jsr     _set_chr_mode_5
;
; disable_irq();
;
	jsr     _disable_irq
;
; irq_array[0] = 0xff; // end of data 
;
	lda     #$FF
	sta     _irq_array
;
; pad1 = pad_poll(0);
;
	lda     #$00
	jsr     _pad_poll
	sta     _pad1
;
; if ((pad1 & PAD_A|PAD_B) == (PAD_A|PAD_B)) {
;
	ldx     #$00
	and     #$80
	ora     #$40
	cmp     #$C0
	bne     L0002
;
; TestMode();
;
	jsr     _TestMode
;
; memfill(wram_array,0,0x2000); 
;
L0002:	jsr     decsp3
	lda     #<(_wram_array)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(_wram_array)
	sta     (sp),y
	lda     #$00
	tay
	sta     (sp),y
	ldx     #$20
	jsr     _memfill
;
; memfill(digits, 0, 0x8);
;
	jsr     decsp3
	lda     #<(_digits)
	ldy     #$01
	sta     (sp),y
	iny
	lda     #>(_digits)
	sta     (sp),y
	lda     #$00
	tay
	sta     (sp),y
	tax
	lda     #$08
	jsr     _memfill
;
; ppu_off(); // screen off
;
	jsr     _ppu_off
;
; set_extended_gfx(X_GFX);
;
	lda     #$00
	jsr     _set_extended_gfx
;
; MultiMusic_Play(0);
;
	lda     #$00
	jsr     _MultiMusic_Play
;
; d_cat = DEFAULT_CATEGORY;
;
	lda     #$00
	sta     _d_cat
;
; vram_adr(NTADR_A(0,0));
;
	ldx     #$20
	jsr     _vram_adr
;
; vram_fill(0x80, 0x3c0); 
;
	lda     #$80
	jsr     pusha
	ldx     #$03
	lda     #$C0
	jsr     _vram_fill
;
; pal_bg(MenuPal);
;
	lda     #<(_MenuPal)
	ldx     #>(_MenuPal)
	jsr     _pal_bg
;
; MAXGAME = CAT_NO[d_cat];
;
	ldx     #$00
	lda     _d_cat
	asl     a
	bcc     L0048
	inx
	clc
L0048:	adc     #<(_CAT_NO)
	sta     ptr1
	txa
	adc     #>(_CAT_NO)
	sta     ptr1+1
	ldy     #$01
	lda     (ptr1),y
	sta     _MAXGAME+1
	dey
	lda     (ptr1),y
	sta     _MAXGAME
;
; rom_shift = CAT_SHF[d_cat];
;
	ldx     #$00
	lda     _d_cat
	asl     a
	bcc     L0049
	inx
	clc
L0049:	adc     #<(_CAT_SHF)
	sta     ptr1
	txa
	adc     #>(_CAT_SHF)
	sta     ptr1+1
	iny
	lda     (ptr1),y
	sta     _rom_shift+1
	dey
	lda     (ptr1),y
	sta     _rom_shift
;
; draw_title(CAT_TXT[d_cat], 5);
;
	ldx     #$00
	lda     _d_cat
	asl     a
	bcc     L004A
	inx
	clc
L004A:	adc     #<(_CAT_TXT)
	sta     ptr1
	txa
	adc     #>(_CAT_TXT)
	sta     ptr1+1
	iny
	lda     (ptr1),y
	tax
	dey
	lda     (ptr1),y
	jsr     pushax
	lda     #$05
	jsr     _draw_title
;
; DrawPage(0, 1);   
;
	lda     #$00
	jsr     pusha
	lda     #$01
	jsr     _DrawPage
;
; ppu_on_all();
;
	jsr     _ppu_on_all
;
; pal_spr(MenuPal_S);
;
	lda     #<(_MenuPal_S)
	ldx     #>(_MenuPal_S)
	jsr     _pal_spr
;
; ppu_wait_nmi();
;
L0004:	jsr     _ppu_wait_nmi
;
; oam_clear();
;
	jsr     _oam_clear
;
; oam_spr(M_X, M_Y+(16*(menu_offset%MAXLINES)), ARR_OFFSET, 0x0);
;
	jsr     decsp3
	lda     #$30
	ldy     #$02
	sta     (sp),y
	lda     _menu_offset
	ldx     _menu_offset+1
	jsr     pushax
	ldx     #$00
	lda     #$08
	jsr     tosmoda0
	asl     a
	asl     a
	asl     a
	asl     a
	clc
	adc     #$42
	ldy     #$01
	sta     (sp),y
	lda     #$B6
	dey
	sta     (sp),y
	tya
	jsr     _oam_spr
;
; oam_spr(M_X+8, M_Y+(16*(menu_offset%MAXLINES)), ARR_OFFSET+1, 0x0);
;
	jsr     decsp3
	lda     #$38
	ldy     #$02
	sta     (sp),y
	lda     _menu_offset
	ldx     _menu_offset+1
	jsr     pushax
	ldx     #$00
	lda     #$08
	jsr     tosmoda0
	asl     a
	asl     a
	asl     a
	asl     a
	clc
	adc     #$42
	ldy     #$01
	sta     (sp),y
	lda     #$B7
	dey
	sta     (sp),y
	tya
	jsr     _oam_spr
;
; pad1 = pad_poll(0);
;
	lda     #$00
	jsr     _pad_poll
	sta     _pad1
;
; pad1_new = get_pad_new(0);
;
	lda     #$00
	jsr     _get_pad_new
	sta     _pad1_new
;
; if (pad1_new & PAD_START) {
;
	and     #$10
	beq     L004D
;
; while (pad1 & PAD_START) {pad1 = pad_poll(0);}
;
	jmp     L004C
L004B:	lda     #$00
	jsr     _pad_poll
	sta     _pad1
L004C:	lda     _pad1
	and     #$10
	bne     L004B
;
; RunGame(menu_offset);
;
	lda     _menu_offset
	ldx     _menu_offset+1
	jsr     _RunGame
;
; if (pad1 & PAD_RIGHT) {
;
L004D:	lda     _pad1
	and     #$01
	jeq     L004F
;
; PlaySnd(0);
;
	lda     #$00
	jsr     _PlaySnd
;
; menu_offset += MAXLINES;
;
	lda     #$08
	clc
	adc     _menu_offset
	sta     _menu_offset
	bcc     L000E
	inc     _menu_offset+1
;
; if (menu_offset >= MAXGAME) {
;
L000E:	lda     _menu_offset
	cmp     _MAXGAME
	lda     _menu_offset+1
	sbc     _MAXGAME+1
	bcc     L0012
;
; if (page >= MAXGAMES-1) {
;
	lda     _page
	jsr     pusha0
	lda     _MAXGAME
	ldx     _MAXGAME+1
	jsr     shrax3
	sec
	sbc     #$01
	bcs     L0011
	dex
L0011:	jsr     tosicmp
	bcc     L0010
;
; menu_offset = (menu_offset % MAXLINES);
;
	lda     _menu_offset
	ldx     _menu_offset+1
	jsr     pushax
	ldx     #$00
	lda     #$08
	jsr     tosmoda0
;
; } else {
;
	jmp     L0013
;
; menu_offset = MAXGAME-1;
;
L0010:	lda     _MAXGAME
	ldx     _MAXGAME+1
	sec
	sbc     #$01
	bcs     L0013
	dex
L0013:	sta     _menu_offset
	stx     _menu_offset+1
;
; page = (menu_offset/MAXLINES);
;
L0012:	lda     _menu_offset
	ldx     _menu_offset+1
	cpx     #$00
	bpl     L0014
	sta     regsave
	stx     regsave+1
	cpx     #$FF
	bne     L0016
	cmp     #$F9
L0016:	jsr     boolult
	lsr     a
	lda     regsave
	ldx     regsave+1
	bcs     L0014
	lda     #$00
	jmp     L004E
L0014:	jsr     asrax3
L004E:	sta     _page
;
; DrawPage(page, 0);
;
	jsr     pusha
	lda     #$00
	jsr     _DrawPage
;
; m_d = menu_offset % MAXLINES;
;
	lda     _menu_offset
	ldx     _menu_offset+1
	jsr     pushax
	ldx     #$00
	lda     #$08
	jsr     tosmoda0
	sta     _m_d
;
; if (pad1 & PAD_LEFT) {  
;
L004F:	lda     _pad1
	and     #$02
	jeq     L0051
;
; PlaySnd(0);    
;
	lda     #$00
	jsr     _PlaySnd
;
; if (page <= 0) { 
;
	lda     _page
	bne     L0018
;
; menu_offset = (menu_offset % MAXLINES) + (MAXLINES * (MAXGAMES-1));
;
	lda     _menu_offset
	ldx     _menu_offset+1
	jsr     pushax
	ldx     #$00
	lda     #$08
	jsr     tosmoda0
	sta     ptr1
	stx     ptr1+1
	lda     _MAXGAME
	ldx     _MAXGAME+1
	jsr     shrax3
	sec
	sbc     #$01
	bcs     L0019
	dex
L0019:	jsr     shlax3
	clc
	adc     ptr1
	pha
	txa
	adc     ptr1+1
	tax
	pla
	sta     _menu_offset
	stx     _menu_offset+1
;
; if (menu_offset >= MAXGAME) {
;
	cmp     _MAXGAME
	txa
	sbc     _MAXGAME+1
	bcc     L001C
;
; menu_offset = MAXGAME-1;
;
	lda     _MAXGAME
	ldx     _MAXGAME+1
	sec
	sbc     #$01
	bcs     L0064
	dex
;
; } else {
;
	jmp     L0064
;
; menu_offset = (menu_offset - MAXLINES) % MAXGAME;
;
L0018:	lda     _menu_offset
	ldx     _menu_offset+1
	sec
	sbc     #$08
	bcs     L001D
	dex
L001D:	jsr     pushax
	lda     _MAXGAME
	ldx     _MAXGAME+1
	jsr     tosumodax
L0064:	sta     _menu_offset
	stx     _menu_offset+1
;
; page = (menu_offset/MAXLINES);
;
L001C:	lda     _menu_offset
	ldx     _menu_offset+1
	cpx     #$00
	bpl     L001E
	sta     regsave
	stx     regsave+1
	cpx     #$FF
	bne     L0020
	cmp     #$F9
L0020:	jsr     boolult
	lsr     a
	lda     regsave
	ldx     regsave+1
	bcs     L001E
	lda     #$00
	jmp     L0050
L001E:	jsr     asrax3
L0050:	sta     _page
;
; DrawPage(page, 0);
;
	jsr     pusha
	lda     #$00
	jsr     _DrawPage
;
; m_d = menu_offset % MAXLINES;
;
	lda     _menu_offset
	ldx     _menu_offset+1
	jsr     pushax
	ldx     #$00
	lda     #$08
	jsr     tosmoda0
	sta     _m_d
;
; if (pad1_new & PAD_DOWN) {
;
L0051:	lda     _pad1_new
	and     #$04
	beq     L0052
;
; menu_hold_delay = 0;
;
	lda     #$00
	sta     _menu_hold_delay
;
; if ((pad1 & PAD_DOWN) && menu_hold_delay <= 0) {
;
L0052:	lda     _pad1
	and     #$04
	beq     L005A
	lda     _menu_hold_delay
	bne     L005A
;
; PlaySnd(0);
;
	jsr     _PlaySnd
;
; menu_offset++;
;
	inc     _menu_offset
	bne     L0026
	inc     _menu_offset+1
;
; m_d++;
;
L0026:	inc     _m_d
;
; if (menu_offset >= MAXGAME) {
;
	lda     _menu_offset
	cmp     _MAXGAME
	lda     _menu_offset+1
	sbc     _MAXGAME+1
	bcc     L0057
;
; if (page > 0) {
;
	lda     _page
	beq     L0047
;
; m_d = MAXLINES;
;
	lda     #$08
;
; m_d = 0;
;
L0047:	sta     _m_d
;
; menu_offset = 0;
;
	lda     #$00
	sta     _menu_offset
	sta     _menu_offset+1
;
; if (m_d >= MAXLINES) {
;
L0057:	lda     _m_d
	cmp     #$08
	bcc     L0059
;
; m_d = 0;
;
	lda     #$00
	sta     _m_d
;
; page = (menu_offset/MAXLINES);
;
	lda     _menu_offset
	ldx     _menu_offset+1
	cpx     #$00
	bpl     L002B
	sta     regsave
	stx     regsave+1
	cpx     #$FF
	bne     L002D
	cmp     #$F9
L002D:	jsr     boolult
	lsr     a
	lda     regsave
	ldx     regsave+1
	bcs     L002B
	lda     #$00
	jmp     L0058
L002B:	jsr     asrax3
L0058:	sta     _page
;
; DrawPage(page, 0);
;
	jsr     pusha
	lda     #$00
	jsr     _DrawPage
;
; menu_hold_delay = 8;
;
L0059:	lda     #$08
	sta     _menu_hold_delay
;
; if (pad1_new & PAD_UP) {
;
L005A:	lda     _pad1_new
	and     #$08
	beq     L005B
;
; menu_hold_delay = 0;
;
	lda     #$00
	sta     _menu_hold_delay
;
; if ((pad1 & PAD_UP) && menu_hold_delay <= 0) {
;
L005B:	lda     _pad1
	and     #$08
	jeq     L002F
	lda     _menu_hold_delay
	jne     L002F
;
; PlaySnd(0);
;
	jsr     _PlaySnd
;
; if (menu_offset <= 0) {
;
	lda     _menu_offset
	cmp     #$01
	lda     _menu_offset+1
	sbc     #$00
	bvc     L0034
	eor     #$80
L0034:	bpl     L0033
;
; menu_offset = MAXGAME-1;
;
	lda     _MAXGAME
	ldx     _MAXGAME+1
	sec
	sbc     #$01
	bcs     L0035
	dex
L0035:	sta     _menu_offset
	stx     _menu_offset+1
;
; m_d = m_d = (menu_offset % MAXLINES);
;
	jsr     pushax
	ldx     #$00
	lda     #$08
	jsr     tosmoda0
	sta     _m_d
	sta     _m_d
;
; page = (menu_offset/MAXLINES);
;
	lda     _menu_offset
	ldx     _menu_offset+1
	cpx     #$00
	bpl     L0036
	sta     regsave
	stx     regsave+1
	cpx     #$FF
	bne     L0038
	cmp     #$F9
L0038:	jsr     boolult
	lsr     a
	lda     regsave
	ldx     regsave+1
	bcs     L0036
	lda     #$00
	jmp     L005F
L0036:	jsr     asrax3
L005F:	sta     _page
;
; if (page > 0) DrawPage(page, 0);    
;
	lda     _page
	beq     L0063
	jsr     pusha
	lda     #$00
	jsr     _DrawPage
;
; } else {
;
	jmp     L0063
;
; menu_offset--;
;
L0033:	lda     _menu_offset
	sec
	sbc     #$01
	sta     _menu_offset
	bcs     L0060
	dec     _menu_offset+1
;
; if (m_d <= 0) {
;
L0060:	lda     _m_d
	bne     L0062
;
; m_d = (menu_offset % MAXLINES);
;
	lda     _menu_offset
	ldx     _menu_offset+1
	jsr     pushax
	ldx     #$00
	lda     #$08
	jsr     tosmoda0
	sta     _m_d
;
; page = (menu_offset/MAXLINES);
;
	lda     _menu_offset
	ldx     _menu_offset+1
	cpx     #$00
	bpl     L003D
	sta     regsave
	stx     regsave+1
	cpx     #$FF
	bne     L003F
	cmp     #$F9
L003F:	jsr     boolult
	lsr     a
	lda     regsave
	ldx     regsave+1
	bcs     L003D
	lda     #$00
	jmp     L0061
L003D:	jsr     asrax3
L0061:	sta     _page
;
; DrawPage(page, 0);
;
	jsr     pusha
	lda     #$00
	jsr     _DrawPage
;
; } else {
;
	jmp     L0063
;
; m_d--;
;
L0062:	dec     _m_d
;
; menu_hold_delay = 8;
;
L0063:	lda     #$08
	sta     _menu_hold_delay
;
; if (menu_hold_delay) menu_hold_delay--;
;
L002F:	lda     _menu_hold_delay
	jeq     L0004
	dec     _menu_hold_delay
;
; while (1){ // infinite loop
;
	jmp     L0004

.endproc

